#!/usr/bin/env python

import json
import os

from tornado.escape import utf8
from tornado.ioloop import IOLoop
from tornado.options import define, options, parse_command_line, parse_config_file
from tornado.web import RequestHandler, Application, asynchronous, authenticated, HTTPError

from async_dropbox import DropboxMixin

define('port', default=8888)
define('flagfile', default='config.flags')
define('debug', default=False)
define('cookie_secret', default=";laksdfjas;lkjdf;lkasdjf;lkasjdfl;k")

# These don't have defaults; see README for details.
define('dropbox_consumer_key')
define('dropbox_consumer_secret')

class BaseHandler(RequestHandler):
    def get_current_user(self):
        print "getting user"
        if self.get_secure_cookie("user"):
            return json.loads(self.get_secure_cookie("user"))
        else:
            return None

    def get_access_token(self):
        # json turns this into unicode strings, but we need bytes for oauth
        # signatures.
        print "getting access token" + str(self.current_user["access_token"])
        return dict((utf8(k), utf8(v)) for (k, v) in self.current_user["access_token"].iteritems())

class RootHandler(BaseHandler, DropboxMixin):
    @authenticated
    @asynchronous
    def get(self):
        print "rendering index.html"
        self.render("index.html")

# where we will Dropbox data from
class JSONHandler(BaseHandler, DropboxMixin):
    @authenticated
    @asynchronous
    def get(self):
        print "sending dropbox request"
        self.dropbox_request('api', '/1/metadata/dropbox/', self.on_metadata,
                             self.get_access_token(),
                             list="true")
    # TODO: get the user's file directory structure
    def on_metadata(self, response):
        metadata = json.load(response.buffer)
        self.set_header("Content-Type", "application/json")
        self.write(json.dumps(metadata))
        self.finish()



# this is called indirectly by our javascript
class UploadHandler(BaseHandler):
    @asynchronous
    def post(self):
        file_to_print = self.request.files['print-upload'][0]
        netid = self.get_argument('net-id')
        args = self.request.arguments

        output_file = tempfile.NamedTemporaryFile(prefix=netid, dir='tmp', delete=False)
        output_file.write(file_to_print['body'])
        output_file.close()

        args['filepath'] = output_file.name
        print_options = self.post_to_lp(args)
        self.send_print_command(print_options)
        os.unlink(output_file.name)    
        
        self.finish()
    """Translates the POST form data to lp command options
        returns a list containing options"""
    def post_to_lp(self, args):
        print_options = ['lp']
        print_options.append('-U')
        print_options.extend(args['net-id'])
    
        copies = args.get('copies', 1)
        print_options.append('-n')
        print_options.extend(copies)
    
        double = args.get('double-sided','yes')
        if double == 'no':
            double = 'sides=one-sided'
        else:
            double = 'sides=two-sided-long-edge'
        pages = args['pages']
        print pages
        print len(pages)
        # check for empty string
        if pages[0] == '':
            print_options.extend(['-o',double])
        else:
            print_options.extend(['-o',double + ' page-ranges='+pages[0]])
        
        filepath = args['filepath']
        i = filepath.rfind('/')
        filepath = filepath[i+1:]
        print_options.append(str(filepath))
        return print_options
    
    """Executes an lp print command on a subprocess. 
       print_options is a list containing the specified print options
       generated by post"""
    def send_print_command(self, print_options):
        self.write("Executing print commad")
        print print_options
        tempdir = os.path.join(os.getcwd(), 'tmp')
        os.chdir(tempdir)
        print os.getcwd()
        subprocess.call(print_options)
        os.chdir('..')
        #self.finish()

class DropboxLoginHandler(BaseHandler, DropboxMixin):
    @asynchronous
    def get(self):
        if self.get_argument("oauth_token", None):
            self.get_authenticated_user(self._on_auth)
            return
        self.authorize_redirect(callback_uri=self.request.full_url())

    def _on_auth(self, user):
        if not user:
            raise HTTPError(500, "Dropbox auth failed")
        self.set_secure_cookie("user", json.dumps(user))
        self.redirect('/')

class LogoutHandler(BaseHandler):
    def get(self):
        self.clear_cookie("user")
        self.redirect("/")

def main():
    parse_command_line()
    parse_config_file(options.flagfile)

    settings = dict(
        login_url='/login',
        debug=True,
        template_path=os.path.join(os.path.dirname(__file__), 'templates'),
        static_path=os.path.join(os.path.dirname(__file__), 'static'),

        cookie_secret=options.cookie_secret,
        dropbox_consumer_key=options.dropbox_consumer_key,
        dropbox_consumer_secret=options.dropbox_consumer_secret,
        )
    app = Application([
            (r'/', RootHandler),
            (r'/login', DropboxLoginHandler),
            (r'/meta', JSONHandler),
            (r"/upload", UploadHandler),
            (r'/logout', LogoutHandler),
            ], **settings)
    print "ePrint server is now running on port: %d" % options.port
    app.listen(options.port)
    IOLoop.instance().start()

if __name__ == '__main__':
    main()
